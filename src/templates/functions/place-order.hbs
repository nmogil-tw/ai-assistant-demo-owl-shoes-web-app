const Airtable = require('airtable');

/**
 * Place Order Function
 *
 * Generated for: {{company.name}}
 * Industry: {{industry.type}}
 * Entity: {{products.entityName}}
 */

exports.handler = async function(context, event, callback) {
  const response = new Twilio.Response();
  response.appendHeader('Content-Type', 'application/json');

  try {
    // Validate Airtable configuration
    if (!context.AIRTABLE_API_KEY || !context.AIRTABLE_BASE_ID) {
      response.setStatusCode(500);
      response.setBody({ error: 'Airtable configuration error. Please check environment variables.' });
      return callback(null, response);
    }

    const base = new Airtable({apiKey: context.AIRTABLE_API_KEY}).base(context.AIRTABLE_BASE_ID);

    // Extract and validate the x-identity header
    const identityHeader = event.request.headers["x-identity"];
    if (!identityHeader) {
      response.setStatusCode(400);
      response.setBody({
        error: 'Missing x-identity header. Provide email or phone in the format: "email:<email>" or "phone:<phone>".'
      });
      return callback(null, response);
    }

    const { product_id } = event;
    if (!product_id) {
      response.setStatusCode(400);
      response.setBody({ error: 'Missing product_id in request body' });
      return callback(null, response);
    }

    // Parse the identity header
    let queryField, queryValue;
    if (identityHeader.startsWith('user_id:')) {
      const userIdValue = identityHeader.replace(/^user_id:/, '').trim();
      if (userIdValue.includes('@')) {
        // If it contains @, treat as email
        queryField = 'email';
        queryValue = userIdValue;
      } else if (userIdValue.includes('+')) {
        // If it contains +, treat as phone
        queryField = 'phone';
        queryValue = userIdValue;
      } else {
        // Default to email for backward compatibility
        queryField = 'email';
        queryValue = userIdValue;
      }
    } else if (identityHeader.startsWith('email:')) {
      queryField = 'email';
      queryValue = identityHeader.replace(/^email:/, '').trim();
    } else if (identityHeader.startsWith('phone:')) {
      queryField = 'phone';
      queryValue = identityHeader.replace(/^phone:/, '').trim();
    } else if (identityHeader.startsWith('whatsapp:')) {
      queryField = 'phone';
      queryValue = identityHeader.replace(/^whatsapp:/, '').trim();
    } else {
      return callback(null, {
        status: 400,
        message: 'Invalid x-identity format. Use "email:<email>", "user_id:<email or phone>" or "phone:<phone>".',
      });
    }

    // Lookup customer
    const customerRecords = await base('customers')
      .select({
        filterByFormula: `{${queryField}} = '${queryValue}'`,
        maxRecords: 1
      })
      .firstPage();

    if (!customerRecords || customerRecords.length === 0) {
      response.setStatusCode(404);
      response.setBody({ error: `No customer found for ${queryField}: ${queryValue}` });
      return callback(null, response);
    }

    const customer = customerRecords[0].fields;

    // Lookup {{products.entityName}}
    const productRecords = await base('{{products.tableName}}')
      .select({
        filterByFormula: `{id} = '${product_id}'`,
        maxRecords: 1
      })
      .firstPage();

    if (!productRecords || productRecords.length === 0) {
      response.setStatusCode(404);
      response.setBody({ error: `No {{products.entityName}} found with id: ${product_id}` });
      return callback(null, response);
    }

    const product = productRecords[0].fields;

    // Calculate final price considering any current discount
    let finalPrice = product.price;
    if (product.current_discount) {
      const discountAmount = parseFloat(product.current_discount);
      if (!isNaN(discountAmount)) {
        finalPrice = product.price * (1 - discountAmount / 100);
      }
    }

    // Generate random 6-digit order ID
    const orderId = Math.floor(100000 + Math.random() * 900000).toString();

    // Build order item with industry-specific fields
    const orderItem = {
      id: product.id,
      name: product.name,
      price: finalPrice,
      quantity: 1,
      image_url: product.image_url,
      category: product.category,
      brand: product.brand{{#each products.schema.industryFields}},
      {{name}}: product.{{name}}{{/each}}
    };

    // Create order record
    const orderData = {
      id: orderId,
      customer_id: customer.id,
      email: customer.email,
      phone: customer.phone,
      items: JSON.stringify([orderItem]),  // Airtable requires stringified JSON for complex objects
      total_amount: finalPrice,
      shipping_status: 'pending'
    };

    const newOrder = await base('orders').create([
      { fields: orderData }
    ]);

    if (!newOrder || newOrder.length === 0) {
      response.setStatusCode(500);
      response.setBody({ error: 'Failed to create order record' });
      return callback(null, response);
    }

    // Return success response
    response.setStatusCode(200);
    response.setBody({
      message: 'Order created successfully',
      order_id: orderId,
      order_details: {
        customer: {
          name: `${customer.first_name} ${customer.last_name}`,
          email: customer.email,
          shipping_address: {
            address: customer.address,
            city: customer.city,
            state: customer.state,
            zip_code: customer.zip_code
          }
        },
        {{products.entityName}}: {
          name: product.name,
          price: finalPrice,
          original_price: product.price,
          discount_applied: product.current_discount || '0'
        }
      }
    });

    return callback(null, response);

  } catch (error) {
    console.error('Unexpected error:', error);
    response.setStatusCode(500);
    response.setBody({ error: 'Internal server error' });
    return callback(null, response);
  }
};
